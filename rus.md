# Разрабатываем API на JavaScript лучше

Рано или поздно вы обнаружите, что пишете на JavaScript код, который сложнее
пары строчек плагина jQuery. Ваш код будет делать огромное количество вещей,
им будет (в идеале) пользоваться множество людей с разными подходами к вашему
коду. У них будут различные уровни потребностей, знаний и ожиданий.

![Время, потраченное на создание и на использование][1]

Эта статья описывает наиболее важные вещи, которые вам следует иметь в виду
до и во время написания собственных утилит и библиотек. Мы обратим внимание
на то, каким образом сделать код доступным для других разработчиков.
Для освещения нескольких тем мы затронем jQuery в целях демонстрации, однако
эта статья не о jQuery и не о том, как писать для него плагины.

Питер Друкер однажды выразился: «Компьютер — идиот». Не пишите код для
идиотов, пишите для людей! Давайте же окунёмся в **разработку таких API,
которые полюбятся разработчикам**.

### Текучий интерфейс

[Текучим интерфейсом][2] часто называют *цепные вызовы* (хотя это всего
половина правды). В глазах новичков он выглядит как *стиль jQuery*.
Хотя я и уверен, что стиль API стал ключевым фактором успеха jQuery, он не
был ими изобретён, лавры создателя, похоже, принадлежат Мартину Фаулеру,
который [придумал этот термин][3] ещё в 2005, примерно за год до релиза
jQuery. Но с другой стороны, Фаулер лишь дал этому понятию название, текучие
интерфейсы использовались и гораздо раньше.

Кроме значительных упрощений, jQuery позволил сгладить серьёзные различия
между браузерами. jQuery всегда был *текучим интерфейсом*, и это мне
нравилось больше всего в этой крайне успешной библиотеке. Я наслаждался именно
таким API настолько, что сразу стало ясно: именно такой стиль я хочу
использовать в [URI.js][4]. Во время тонкой настройки API URI.js, я постоянно
просматривал исходники jQuery в поисках маленьких трюков, которые позволили бы
сделать мою реализацию настолько простой, насколько это возможно. И оказалось,
что не я один прилагал усилия вэтом направлении. [Леа Веру][5] создала
[chainvas][6], утилиту для оборачивания обычных API с гетерами и сеттерами
в приятные текучие интефейсы. [`_.chain()`][7] в Underscore тоже делает что-то
подобное. В сущности, большинство библиотек нового поколения поддерживают 
цепные вызовы.

#### Цепные вызовы

Главная цель [цепных вызовов][8] в том, чтобы код как можно более легко
читался с тем, чтобы его можно понять быстрее. Используя *цепные вызовы*,
можно сделать код похожим на предложения, делая их проще для чтения и при этом
избавляясь от шума:

    // обычные вызовы API для смены парочки цветов и добавления обработчика события
    var elem = document.getElementById("foobar");
    elem.style.background = "red";
    elem.style.color = "green";
    elem.addEventListener('click', function(event) {
      alert("hello world!");
    }, true);
    
    // (воображаемый) API с цепным вызовом
    DOMHelper.getElementById('foobar')
      .setStyle("background", "red")
      .setStyle("color", "green")
      .addEvent("click", function(event) {
        alert("hello world");
      });

Обратите внимания, нам не пришлось хранить ссылку на элемент в переменной и
повторять её снова и снова.

#### Разделение команд и запросов

[Разделение команд и запросов][9] (CQS) — это концепция, пришедшая из
императивного программирования. Функции, изменяющие состояние (внутренние
значения) объекта, называются *командами*, функции, получающие значения,
называются *запросами*. Общий принцип: запросы возвращают данные, команды
меняют состояние, но никогда и то и другое вместе. Эта концепция лежит в
основе повседневных геттеров и сеттеров, которые мы можем увидеть в
большинстве современных библиотек. Коль скоро *текучие интерфейсы* возвращают
ссылку на себя для цепного вызова методов, мы уже нарушаем правило для
*команд*, потому как они по-хорошему не должны ничего возвращать. Вдовесок
к этой (легко игнорируемой) особенности мы (преднамеренно) отходим от этого
принципа с тем, чтобы придерживаться максимальной простоты в API.
Отличный пример такого подхода — метод [`css()`][10] jQuery:

    var $elem = jQuery("#foobar");
    
    // CQS - команда
    $elem.setCss("background", "green");
    // CQS - запрос
    $elem.getCss("color") === "red";
    
    // не-CQS - команда
    $elem.css("background", "green");
    // не-CQS - запрос
    $elem.css("color") === "red";

Как вы можете увидеть, и геттер, и сеттер объединены в один метод. Действие,
которое следует совершить (а именно, *запрос* или *команду*), определяется
по количеству аргументов, переданных в функцию, а не тем, какая функция
вызывается. Это позволяет экспортировать меньше методов и, в свою очередь,
меньше печатать, чтобы добиться той же цели.

Чтобы создать текучий интерфейс, сжимать геттеры и сеттеры в один метод вовсе
не обязательно, это скорее дело вкуса. Ваша документация должна явно
указывать, какой именно подход вы используете. Мы вернёмся к теме
документирования API позже, а сейчас я хотел бы заметить, что функции со
множественными сигнатурами, возможно, будет сложнее документировать.

#### Переходим к текучести

Хотя текучесть уже по большей части обеспечивается цепными вызовами, мы ещё
не закончили. Следующий шаг к *текучести* поможет продемонстрировать такой
пример: представим, что мы пишем маленькую библиотечку для работы с
интервалами дат. Интервал начинается с даты и датой заканчивается. Дата
не обязательно связана с интервалом. Размышляя так мы приходим к простому
конструктору:

    // создаём новый временной интервал
    var interval = new DateInterval(startDate, endDate);
    // получаем посчитанное количество дней в интервале
    var days = interval.days();

Хотя на первый взгляд кажется, что всё верно, этот пример показывает, что
не так:

    var startDate = new Date(2012, 0, 1);
    var endDate = new Date(2012, 11, 31)
    var interval = new DateInterval(startDate, endDate);
    var days = interval.days(); // 365

Мы написали целую кучу переменных и хлама, который нам, возможно, не нужен.
Хорошим решением этой проблемы было бы добавление объекту Date функции,
которая возвращает интервал:

    // создаёт DateInterval для текучего вызова
    Date.prototype.until = function(end) {
    
      // если дата не была передана, создаём её
      if (!(end instanceof Date)) {
        // создаём дату, передавая полученные аргументы 
        // в конструктор без изменения, таким образом,
        // эта функция принимает точно такие
        // же параметры, как и конструктор Date.
        end = Date.apply(null, 
          Array.prototype.slice.call(arguments, 0)
        );
      }
    
      return new DateInterval(this, end);
    };

Так мы создали `DateInterval` в текучей, лёгкой для написания и прочтения
манере:

    var startDate = new Date(2012, 0, 1);
    var interval = startDate.until(2012, 11, 31);
    var days = interval.days(); // 365
    
    // сжатый вызов текучего интерфейса:
    var days = (new Date(2012, 0, 1))
      .until(2012, 11, 31) // возвращает экземпляр DateInterval
      .days(); // 365

Как вы видите, в последнем примере пришлось объявить меньше переменных и
написать меньше кода, а сама операция читается как предложение на английском
языке. Этот пример был призван помочь вам осознать, что цепные вызовы — это
лишь часть текучего интерфейса, и эти понятия не синонимы. Для обеспечения
текучести вы должны думать о потоках кода — откуда вы начинаете, и куда
направляетесь.

`//TODO: Перевести следующий абзац ближе к тексту`

Этот пример иллюстрировал текучесть через расширение нативного объекта
произвольной функцией. Это такой же предмет религиозных войн, как и вопрос,
надо ли использовать точки с запятой, или нет. В статье
[Расширение встроенных нативных объектов. Зло или нет?][11] [kangax][12]
объясняет плюсы и минусы такого подхода. Хотя у каждого есть своё мнение,
все сходятся в одном: в таких вещах нужно единообразие. Впрочем, даже
приверженцы позиции «нельзя загрязнять нативные объекты своими функциями»
допустили бы такой, по-своему текучий, приём:

    String.prototype.foo = function() {
      return new Foo(this);
    }
    
    "Я нативный объект".foo()
      .iAmACustomFunction();

С таким подходом ваши функции по-прежнему находятся внутри собственного
пространства имён, но при этом достуны через другой объект. Убедитесь, что
ваш эквивалент `.foo()` не является общим термином и очень навряд ли
пересечётся с другими API. Убедитесь, что вы должным образом предоставили
методы [`.valueOf()`][13] и [`.toString()`][14], чтобы объекты можно было
преобразовать обратно в изначальные примитивные типы.

### Единообразие

У [Джейка Арчибальд][15] был слайд с определением слова *единообразие*.
Оно гласило просто: [*не PHP*][16]. Не. Дай. Бог. Вы вздумаете назвать
функцию вроде *str_repeat()*, *strpos()*, *substr()*. Также никогда в жизни
не меняйте позиции аргументов. Если вы объявили в каком-то одном месте 
`find_in_array(haystack, needle)`, то добавление
`findInString(needle, haystack)` призовёт разъярённую толпу зомби подняться
из своих могил, выследить вас и заставить писать на delphi до скончания
жизни!

#### Именование вещей

> «В вычислительной науке всего две сложные задачи: инвалидация кэша
> и именование переменных.»
>
> — Фил Карлтон

`//TODO: двойное отрицание, проверить!`

Я бывал на многих встречах и конференциях, пытаясь научиться тонкостям
именования. Я не ушёл ни с одной из них, не услышав упомянутой выше цитаты,
и так и не научился, как же всё-таки называть вещи.
Мой совет сводится к *называйте кратко но осмысленно, и доверьтесь интуиции*.
Но прежде всего, соблюдайте единообразие.

В примере с `DateInterval` выше был метод под названием `until()`. Мы могли
бы назвать эту функцию `interval()`. Последнее было бы ближе к возвращаемому
значению, хотя первое более *человеко-читаемое*. Подберите такие формулировки,
какие вам нравятся, и придерживайтесь их. Единообразие — это 90% того, что
имеет значение. Выберите один стиль и сохраняйте этот стиль, даже если в
будущем он вам разонравится.

### Обработка аргументов

![Благие намерения][17]

То, каким образом ваши методы принимают значения, важнее, чем стремление
сделать их цепными. Цепные вызовы — это достаточно обыденная вещь, которую
несложно воплотить в коде, а вот обработка аргументов — нет. Вам нужно
продумать то, как скорее всего будут использоваться предоставленные вами
методы. Будет ли код, использующий ваш API, повторять определённые
вызовы функций? Почему эти вызовы будут повторяться? Как может ваш API
помочь разработчику уменьшить шум от повторяющихся вызовов методов?

Метод [`css()`][10] в jQuery может устанавливать стили элементов DOM:

    jQuery("#some-selector")
      .css("background", "red")
      .css("color", "white")
      .css("font-weight", "bold")
      .css("padding", 10);

Выявилась закономерность! Каждый вызов метода указывает имя стиля и определяет
значение для него. Возможность передать эти данные в виде объекта-словаря так
и просится:

    jQuery("#some-selector").css({
      "background" : "red",
      "color" : "white",
      "font-weight" : "bold",
      "padding" : 10
    });

Метод [`on()`][18] jQuery может регистрировать обработчики событий. Как и
`css()`, он может принимать словарь событий, но идёт ещё дальше, позволяя
зарегистрировать один обработчик на несколько событий:

    // привязываемся к событиям, передавая словарь:
    jQuery("#some-selector").on({
      "click" : myClickHandler,
      "keyup" : myKeyupHandler,
      "change" : myChangeHandler
    });
    
    // привязываем обработчик к нескольким событиям:
    jQuery("#some-selector").on("click keyup change", myEventHandler);

Вы можете предоставить подобные сигнатуры функций используя *паттерн Метод*:

    DateInterval.prototype.values = function(name, value) {
      var map;
    
      if (jQuery.isPlainObject(name)) {
        // устанавливаем словарь
        map = name;
      } else if (value !== undefined) {
        // устанавливаем значение (возможно, на нескольких именах),
        // преобразуем в словарь
        keys = name.split(" ");
        map = {};
        for (var i = 0, length = keys.length; i < length; i++) {
          map[keys[i]] = value;
        }
      } else if (name === undefined) {
        // получаем все значения
        return this.values;
      } else {
        // получаем конкретное значение
        return this.values[name];
      }
    
      for (var key in map) {
        this.values[name] = map[key];
      }
    
      return this;
    };

Если вы работаете с коллекциями, подумайте, как бы вы смогли уменьшить
количество циклов, которые придется создать пользователю вашего API.
Скажем, у нас есть несколько элементов `<input>`, которым мы хотим установить
значение по умолчанию:

    <input type="text" value="" data-default="foo">
    <input type="text" value="" data-default="bar">
    <input type="text" value="" data-default="baz">

Скорее всего, мы пройдёмся по ним в цикле:

    jQuery("input").each(function() {
      var $this = jQuery(this);
      $this.val($this.data("default"));
    });

Что если мы бы могли обойтись без этого метода, используя простой коллбек,
который применится к каждому `<input>` в коллекции? Разработчики jQuery
подумали об этом, и позволили нам писать меньше™:

    jQuery("input").val(function() {
      return jQuery(this).data("default");
    });

Такие маленькие вещи, вроде возможности передавать словари, коллбеки, или
сериализованные имена атрибутов, делают ваш API не только более чистым, но и
более удобным и эффективнм в использовании. Очевидно, не во всех методах
вашего API станут лучше от паттерна Метод, и вам решать, где он имеет
смысл, а где лишь пустая трата времени. Постарайтесь в этом отношении
соблюдать единообразие настолько, насколько это в человеческих силах.
*Уменьшите необходимость в шаблонном коде при помощи трюков, описанных выше,
и люди станут ставить вам выпивку*.

#### Обработка типов

Когда вы определяете функцию с параметрами, вы решаете, какие данные эта
функция будет принимать. Функция для определения количества дней между двумя
датами могла бы выглядеть так:

    DateInterval.prototype.days = function(start, end) {
      return Math.floor((end - start) / 86400000);
    };

Как видите, функция принимает числа в качестве параметров — метки времени
в миллисекундах, если быть точнее. Хотя функция и справляется с тем, на что
рассчитана, она не очень-то гибкая. А что, если мы работаем с объектами `Date`,
или со строковыми представлениями дат? Пользователю придётся всяких раз
приводить данные к нужному виду? Нет! В нашем API простые операции проверки
входных данных и их приведения должны находиться в единственном месте, а не
быть раскиданными по всему коду:

    DateInterval.prototype.days = function(start, end) {
      if (!(start instanceof Date)) {
        start = new Date(start);
      }
      if (!(end instanceof Date)) {
        end = new Date(end);
      }
    
      return Math.floor((end.getTime() - start.getTime()) / 86400000);
    };

Мы добавили шесть строчек и дали функции возможность принимать на вход объект
Date, метку времени в виде числа, или даже строковое представление вроде
`Sat Sep 08 2012 15:34:35 GMT+0200 (CEST)`. Мы не знаем, как и для чего люди
будут использовать наш код, но проявив немного предусмотрительности, можем
быть уверены, что интеграция нашего кода пройдёт безболезненно.

Опытный разработчик может заметить ещё одну проблему в нашем коде. Мы
предполагаем, что `start` будет перед `end`. Если пользователь API случайно
поменяет местами даты, ему вернётся отрицательно количество дней между
`start` и `end`. Остановитесь и хорошенько продумайте такие ситуации.
Если вы решите, что отрицательное значение не имеет смысла, поправьте это:

    DateInterval.prototype.days = function(start, end) {
      if (!(start instanceof Date)) {
        start = new Date(start);
      }
      if (!(end instanceof Date)) {
        end = new Date(end);
      }
    
      return Math.abs(Math.floor((end.getTime() - start.getTime()) / 86400000));
    };

JavaScript позволяет приводить типы множеством способов. Если вы работаете
с примитивами (string, number, boolean), это можно сделать просто (и кратко):

    function castaway(some_string, some_integer, some_boolean) {
      some_string += "";
      some_integer += 0; // parseInt(some_integer, 10) безопаснее
      some_boolean = !!some_boolean;
    }

Я не настаиваю на том, чтобы вы делали так всегда. Но эти невинно выглядящие
строчки могут сохранить время и избавить от страданий во время встраивания
вашего кода.

#### Рассматриваем `undefined` как ожидаемое значение

Рано или поздно окажется, что ваш API будет ожидать `undefined` в качестве
значения, которое нужно установить атрибуту. Может быть, для «удаления»
атрибута или для обработки некорректных параметров с целью ускорить работу
вашего API. Чтобы определить, что значение `undefined` было явным образом
передано в ваш метод, вы можете проверить объект [`arguments`][19]:

    function testUndefined(expecting, someArgument) {
      if (someArgument === undefined) {
        console.log("someArgument является undefined");
      }
      if (arguments.length > 1) {
        console.log("но он был передан явно");
      }
    }
    
    testUndefined("foo");
    // выведется: someArgument является undefined
    testUndefined("foo", undefined);
    // выведется: someArgument является undefined, но он был передан явно

#### Именованные аргументы

    event.initMouseEvent(
      "click", true, true, window,
      123, 101, 202, 101, 202,
      true, false, false, false,
      1, null);

Сигнатура функции [Event.initMouseEvent][20] — это кошмар наяву. Нет никаких
шансов, что какой-нибудь разработчик вспомнит, что означает `1` (предпоследний
параметр), не заглянув в документацию. Неважно, насколько хороша ваша
документация, прилагайте все усилия к тому, чтобы людям не пришлось искать
вещи!

#### Как у других

Выглянув за пределы нашего с вами любимого языка, мы обнаружим в Python
концепцию под названием [именованные аргументы][21]. С её помощью можно
определить значения по умолчанию для аргументов функции, что позволит
при вызове передавать данные при помощи имён.

    function namesAreAwesome(foo=1, bar=2) {
      console.log(foo, bar);
    }
    
    namesAreAwesome();
    // prints: 1, 2
    
    namesAreAwesome(3, 4);
    // prints: 3, 4
    
    namesAreAwesome(foo=5, bar=6);
    // prints: 5, 6
    
    namesAreAwesome(bar=6);
    // prints: 1, 6

При использовании такой схемы вызов функции initMouseEvent() мог бы стать
наглядным:

    event.initMouseEvent(
      type="click",
      canBubble=true,
      cancelable=true,
      view=window,
      detail=123,
      screenX=101,
      screenY=202,
      clientX=101,
      clientY=202,
      ctrlKey=true,
      altKey=false,
      shiftKey=false,
      metaKey=false,
      button=1,
      relatedTarget=null);

В JavaScript это пока невозможно. Хотя в «следующую версию JavaScript» (часто
называемая ES.next, ES6 или Harmony) войдут
[значения параметров по умолчанию][22] и
[дополнительных позиционных параметров][23], про именованные параметры там
до сих пор ни слова.

#### Словари аргументов

JavaScript не Python (а до ES.next как до Луны пешком), у нас остаётся не так
уж много способов решить проблему «зарослей аргументов». В jQuery (и почти
любом другом современном API) решено использовать понятие «объект с опциями».
Сигнатура [jQuery.ajax()][24] — яркий тому пример. Вместо многочисленных
аргументов, мы просто принимаем объект:

    function nightmare(accepts, async, beforeSend, cache, complete, /* и ещё 28 */) {
      if (accepts === "text") {
        // готовимся получить текст
      }
    }
    
    function dream(options) {
      options = options || {};
      if (options.accepts === "text") {
        // готовимся получить текст
      }
    }

Это не только избавляет нас от безумно длинных сигнатур функций, но ещё и
делает вызов функции более наглядным:

    nightmare("text", true, undefined, false, undefined, /* и ещё 28 */);
    
    dream({
      accepts: "text",
      async: true,
      cache: false
    });

А ещё, нам не придётся трогать сигнатуру функции (добавлять аргументы), если
в будущем мы заходит добавить новую фичу.

#### Значения по умолчанию в аргументах

[jQuery.extend()][25], [_.extend()][26] и [Object.extend][27] из библиотеки
Prototype — функции для объединения объектов, они позволяют примешать ваши
собственные, заранее указанные, опции к переданным:

    var default_options = {
      accepts: "text",
      async: true,
      beforeSend: null,
      cache: false,
      complete: null,
      // …
    };
    
    function dream(options) {
      var o = jQuery.extend({}, default_options, options || {});
      console.log(o.accepts);
    }
    
    // make defaults public
    dream.default_options = default_options;
    
    dream({ async: false });
    // выведется: "text"

Вы получите бонусные очки, если сделаете значения по умолчанию публично
видимыми. Так любой сможет поменять `accepts` на «json» в единственном
месте и не придётся указывать эту опцию снова и снова. Обратите внимание,
что в примере добавляется `|| {}` при первом чтении объекта с опциями. Это
позволяет вызывать функцию вообще без параметров.

#### Благие намерения, также известные как «западня»

Теперь, когда вы знаете, как по-настоящему гибко принимать аргументы, нам
нужно вернуться к старой поговорке:

> «С большой силой приходит большая ответственность!»
>
> — Вольтер

Как и большинство слабо типизированных языков, JavaScript делает
автоматическое приведение когда это нужно. Простой пример, проверка на
истинность:

    var foo = 1;
    var bar = true;
    
    if (foo) {
      // ага, выполнится
    }
    
    if (bar) {
      // ага, выполнится
    }

Мы полностью привыкли к этому автоматическому приведению. Мы пользовались
этим столько раз, что уже забыли, что если что-то истинно, то это не
обязательно булева истина. Некоторые API настолько гибкие, что они *слишком
умные*, для их же блага. Взглянем на сигнатуры [jQuery.toggle()][28]:

    .toggle( /* int */ [длительность] [, /* function */  коллбек] )
    .toggle( /* int */ [длительность] [, /* string */  смягчение] [, /* function */ коллбек] )
    .toggle( /* bool */ показатьИлиСкрыть )

Придётся потратить какое-то время, чтобы выяснить, почему это работает
*совершенно* по-разному:

    var foo = 1;
    var bar = true;
    var $hello = jQuery(".hello");
    var $world = jQuery(".world");
    
    $hello.toggle(foo);
    $world.toggle(bar);

Мы *ожидали* использовать сигнатуру `показатьИлиСкрыть` в обоих случаях.
Но вот, что произошло на самом деле: `$hello` переключает свою видимость с
`длительность`ю в 1 миллисекунду. Это не баг jQuery, это простой случай, когда
*ожидания не оправдались*. Даже если вы разработчик на jQuery со стажем,
вы *будете* рано или поздно на этом спотыкаться.

Вы вольны добавить столько удобства / сахара, сколько вам захочется, но не
жертвуйте чистотой и скоростью API в погоне за этим. Если вы заметите, что
написали что-то подобное, подумайте над тем, чтобы вместо этого добавить
отдельный метод, скажем, `.toggleIf(bool)`. И какой выбор вы бы ни сделали,
соблюдайте единообразие!

### Расширяемость

![Разработка возможностей][29]

Рассмотрев объекты опций, мы охватили тему расширяемой конфигурации. Давайте
поговорим о том, как предоставить возможность пользователю расширить ядро и
сам API. Это важная тема, потому как это позволит вам сконцентрироваться на
важных вещах, в то время как другие пользователи будут самостоятельно
заниматься граничными случаями. Хорошие API — это краткие API. Иметь пригоршню
опций для настройки неплохо, а если их будет пара дюжин, то ваше API будет
обущаться как раздутое и непонятное. Обращайте внимание только на те случаи,
где API используется по прямому назначению, делайте только те вещи, которые
понадобятся большинству пользователей вашего API. Всё остальное предоставьте
им самим. Есть несколько способов дать пользователям API возможность расширять
ваш код в соответствии с их потребностями…

#### Коллбеки

Расширяемости через конфигурацию можно добиться при помощи коллбеков. Их
можно предоставить пользователю API с тем, чтобы он мог изменить поведение
определённых частей вашего кода. Если вы чувствуете, что какие-то задачи
могут обрабатываться иначе, чем в вашем коде, сделайте этот кусок кода
настраиваемым коллбеком, чтобы позволить пользователю API с лёгкостью
его переопределить:

    var default_options = {
      // ...
      position: function($elem, $parent) {
        $elem.css($parent.position());
      }
    };
    
    function Widget(options) {
      this.options = jQuery.extend({}, default_options, options || {});
      this.create();
    };
    
    Widget.prototype.create = function() {
      this.$container = $("<div></div>").appendTo(document.body);
      this.$thingie = $("<div></div>").appendTo(this.$container);
      return this;
    };
    
    Widget.protoype.show = function() {
      this.options.position(this.$thingie, this.$container);
      this.$thingie.show();
      return this;
    };

    var widget = new Widget({
      position: function($elem, $parent) {
        var position = $parent.position();
        // располагаем $elem в нижнем правом углу $parent
        position.left += $parent.width();
        position.top += $parent.height();
        $elem.css(position);
      }
    });
    widget.show();

Также через коллбеки часто предоставляется возможность настроить элементы,
созданные при помощи вашего кода:

    // по умолчанию соллбек на создание элемента ничего не делает
    default_options.create = function($thingie){};
    
    Widget.prototype.create = function() {
      this.$container = $("<div></div>").appendTo(document.body);
      this.$thingie = $("<div></div>").appendTo(this.$container);
      // запускаем коллбек на создание, чтобы позволить изменить объект
      this.options.create(this.$thingie);
      return this;
    };

    var widget = new Widget({
      create: function($elem) {
        $elem.addClass('my-style-stuff');
      }
    });
    widget.show();

Всякий раз, когда вы принимаете коллбеки, убедитесь, что их сигнатуры описаны
в документации с примерам работы, так вы поможете пользователям вашего API
настраивать ваш код. Убедитесь, что вы соблюдаете единообразие в отношении
контекста (куда указывает `this`) коллбеков и их аргументов.

#### События

События — привычное дело при работе с DOM. В приложениях помасштабней мы
используем события в различных проявлениях (например, PubSub), чтобы наладить
связь между модулями. События особенно полезны и естественны в работе с
виджетами UI. Библиотеки вроде jQuery предоставив простые интерфейсы, с ними
вы можете легко овладеть этой областью.

Интерфейс событий, как подсказывает название, лучшего всего применим там,
где что-то происходит. Отображение или скрывание какой-нибудь виджета
может зависеть от внешних недосягаемых факторов. Другая частая задача —
обновление виджета, когда он показан. Обе эти задачи можно очень легко решить
с интерфейсом событий jQuery, который к тому же позволяет события
делегировать:

    Widget.prototype.show = function() {
      var event = jQuery.Event("widget:show");
      this.$container.trigger(event);
      if (event.isDefaultPrevented()) {
        // обработчик события не позволяет нам показываться
        return this;
      }
    
      this.options.position(this.$thingie, this.$container);
      this.$thingie.show();
      return this;
    };

    // listen for all widget:show events
    $(document.body).on('widget:show', function(event) {
      if (Math.random() > 0.5) {
        // не позволять виджету показываться
        event.preventDefault();
      }
    
      // update widget's data
      $(this).data("last-show", new Date());
    });
    
    var widget = new Widget();
    widget.show();

Вы можете выбирать имена событий как вам вздумается. Только не используйте
[нативные события][30] для своих целей и, будьте добры, выносите ваши события
в отдельное пространство имён. В jQuery UI имена событий составляются из
имени виджета и имени события `dialogshow`. Мне кажется, что это нечитаемо, и
часто использую просто `dialog:show`, главным образом из-за того, что так
сразу очевидно, что это нестандартное событие, а не какая-то скрытая
особенность браузера.

### Хуки

Традиционные геттеры и сеттеры могут в особенности выиграть от использования
хуков. Хуки обычно отличаются от коллбеков их количеством и тем, как они
устанавливаются. В то время как коллбеки обычно используются на уровне
экземпляров для конкретных задач, хуки обычно используются на глобальном
уровне для изменения значений или выполнения произвольных действий.
В качестве примера применения хуков рассмотрим [cssHooks jQuery][31]:

    // определяем хук для произвольного css
    jQuery.cssHooks.custombox = {
      get: function(elem, computed, extra) {
        return $.css(elem, 'borderRadius') == "50%"
          ? "circle"
          : "box";
      },
      set: function(elem, value) {
        elem.style.borderRadius = value == "circle"
          ? "50%"
          : "0";
      }
    };
    
    // применям .css(), который использует этот хук
    $("#some-selector").css("custombox", "circle");

Зарегистрировав хук `custombox`, мы наделили метод `.css()` jQuery
способностью обрабатывать ранее недоступное свойство CSS. В свой статье
[хуки в jQuery][32] я рассказываю о других хуках, предоставляемых jQuery и
о том, как их можно применять. Вы можете предоставлять хуки примерно так же,
как и коллбеки:

    DateInterval.nameHooks = {
      "yesterday" : function() {
        var d = new Date();
        d.setTime(d.getTime() - 86400000);
        d.setHours(0);
        d.setMinutes(0);
        d.setSeconds(0);
        return d;
      }
    };
    
    DateInterval.prototype.start = function(date) {
      if (date === undefined) {
        return new Date(this.startDate.getTime());
      }
    
      if (typeof date === "string" && DateInterval.nameHooks[date]) {
        date = DateInterval.nameHooks[date]();
      }
    
      if (!(date instanceof Date)) {
        date = new Date(date);
      }
    
      this.startDate.setTime(date.getTime());
      return this;
    };

    var di = new DateInterval();
    di.start("yesterday");

В какой-то степени, хуки — это набор коллбеков, созданных для обработки
произвольных значений в вашем коде. С хуками вы по-прежнему можете
контролировать почти всё, но при этом оставляя пользователям API возможность
изменения поведения.

### Генерирование аксессоров

![Дублирование][33]

Скорее всего, в любом API содержится множество методов-аксессоров (геттеров,
сеттеров, экзекуторов), которые делают похожие вещи. Вернёмся к примеру с
`DateInterval`. Там мы наверняка предоставили бы методы `start()` и `end()`
для управления интервалами. Просто решение может выглядеть так:

    DateInterval.prototype.start = function(date) {
      if (date === undefined) {
        return new Date(this.startDate.getTime());
      }
    
      this.startDate.setTime(date.getTime());
      return this;
    };
    
    DateInterval.prototype.end = function(date) {
      if (date === undefined) {
        return new Date(this.endDate.getTime());
      }
    
      this.endDate.setTime(date.getTime());
      return this;
    };

Как видите, куча повторяющегося кода. Принцип «не повторяйся» подсказывает
воспользваться шаблоном-генератором:

    var accessors = ["start", "end"];
    for (var i = 0, length = accessors.length; i < length; i++) {
      var key = accessors[i];
      DateInterval.prototype[key] = generateAccessor(key);
    }
    
    function generateAccessor(key) {
      var value = key + "Date";
      return function(date) {
        if (date === undefined) {
          return new Date(this[value].getTime());
        }
    
        this[value].setTime(date.getTime());
        return this;
      };
    }

Такой подход позволит вам генерировать несколько похожих методов-аксессоров
вместо того, чтобы указывать их по-отдельности. Если ваши аксессоры требуют
больше данных при генерации, чем просто строка, можно использовать что-то
подобное:

    var accessors = {"start" : {color: "green"}, "end" : {color: "red"}};
    for (var key in accessors) {
      DateInterval.prototype[key] = generateAccessor(key, accessors[key]);
    }
    
    function generateAccessor(key, accessor) {
      var value = key + "Date";
      return function(date) {
        // тут делаем что-нибудь полезное,
        // используя `key` и `accessor.color`
      };
    }

В главе *Обработка аргументов* мы говорили о паттерне Метод, позволяющем
вашим геттерам и сеттерам принимать значения различных полезных типов, вроде
словарей и массивов. Паттерн Метод сам по себе достаточно универсален и его
можно с легкостью превратить в генератор:

    function wrapFlexibleAccessor(get, set) {
      return function(name, value) {
        var map;
    
        if (jQuery.isPlainObject(name)) {
          // устанавливаем словарь
          map = name;
        } else if (value !== undefined) {
          // устанавливаем значение (возможно, на нескольких именах),
          // преобразуем в словарь
          keys = name.split(" ");
          map = {};
          for (var i = 0, length = keys.length; i < length; i++) {
            map[keys[i]] = value;
          }
        } else {
          return get.call(this, name);
        }
    
        for (var key in map) {
          set.call(this, name, map[key]);
        }
    
        return this;
      };
    }
    
    DateInterval.prototype.values = wrapFlexibleAccessor(
      function(name) { 
        return name !== undefined 
          ? this.values[name]
          : this.values;
      },
      function(name, value) {
        this.values[name] = value;
      }
    );

Углубленное описание искусства написания кода без повторов выходит далеко
за пределы этой статьи. [Patterns for DRY-er JavaScript][35] авторства
[Ребекки Мёрфи][34] и слайды [Матиаса Биненса][36] про то
[как принцип «не повторяйся» влияет на производительность JavaScript][37] —
это хорошее начало для изучения это темы.

### Ужасы передачи по ссылке

В отличие от других языков, JavaScript незнакомы понятия *передачи по ссылке*
или *передачи по значению*. Передача данных по значению — это безопасное
действие. С ним можно быть уверенным, что данные, переданные в ваш API, или
возвращенные вашим API, можно изменять, не боясь поменять внутреннее
состояние. Передача данных по ссылке часто используется для экономии памяти,
данные, переданные по ссылке, могут быть изменены снаружи вашего API и
повлять не его внутреннее состояние.

В JavaScript нельзя указать, что аргументы следует передавать по ссылке или
по значению. Примитивы (строки, числа, булевы значения) трактуаются как
*передача по значению*, а объекты (любые, включая Array, Date) передаются
способом, похожим на *передачу по ссылке*. Если вы сейчас впервые об этом
прочитали, вот вам пример в качестве ликбеза:

    // по значению
    function addOne(num) {
      num = num + 1; // да, num++; делает то же самое
      return num;
    }
    
    var x = 0;
    var y = addOne(x);
    // x === 0 <--
    // y === 1
    
    // по ссылке
    function addOne(obj) {
      obj.num = obj.num + 1;
      return obj;
    }
    
    var ox = {num : 0};
    var oy = addOne(ox);
    // ox.num === 1 <--
    // oy.num === 1

Обработка объектов *по ссылке* может вас пребольно укусить, если вы не будете
осторожны. Вернёмся к примеру с `DateInterval` и рассмотрим такую багу:

    var startDate = new Date(2012, 0, 1);
    var endDate = new Date(2012, 11, 31)
    var interval = new DateInterval(startDate, endDate);
    endDate.setMonth(0); // устанавливаем январь
    var days = interval.days(); // получили 31, а ожидалось 365 - ой!

Если конструктор DateInterval не *сделал копию* (технический термин —
«склонировал») полученные значения, любое изменение оригинальных объектов
отразится на внутреннем поведении DateInterval. Это *обычно* не то, чего
мы хотим или ожидаем.

Обратите внимание, это правдиво и для значений, которые ваш API вернул. Если
вы просто вернёте внутренний объект, любые изменения, совершённые снаружи,
отразятся на внутренних данных. И это наверняка не то, чего бы вам хотелось.
[jQuery.extend()][25], [_.extend()][26] и [Object.extend][27] в Prototype —
это способы легко избавиться от ужасов передачи по ссылке.

Если этого краткое изложение вам кажется недостаточно, прочтите отличную
статью [По ссылке или по значению][38] из [книги с носорогом][39].

### Проблема продолжения

В текучем интерфейсе все методы в цепочке вызовов выполняются независимо от
состояния базового объекта. К примеру, вызовем несколько методов на
экземпляре jQuery, который не содержит элементов DOM:

    jQuery('.wont-find-anything')
      // методы выполнятся, хотя им и нечего делать
      .somePlugin().someOtherPlugin();

В не-текучем коде мы можем предотвратить вызов этих функций:

    var $elem = jQuery('.wont-find-anything');
    if ($elem.length) {
      $elem.somePlugin().someOtherPlugin();
    }

Когда мы используем цепные вызовы, мы теряем возможность сделать так, чтобы
какие-то вещи не происходили — мы не можем никуда деться из цепи. Пока
разработчик API знает, что у объекта бывают состояния, когда нужно сделать
лишь `return this;`, всё хорошо. В зависимости того, что ваши методы делают
внутри себя, может оказаться полезным добавить тривиальную проверку на пустоту
объекта:

    jQuery.fn.somePlugin = function() {
      if (!this.length) {
        // Отставить! Нам тут делать нечего
        return this;
      }
    
      // делаем какие-то тяжёлые вычисления для настройки
      for (var i = 10000; i > 0; i--) {
        // Я всего лишь трачу попусту ваше драгоценное процессорное время
        // Если вы будете запускать меня достаточно часто,
        // я превращу ваш лэптоп в сталеплавильную печь
      }
    
      return this.each(function() {
        // делаем полезную работу
      });
    };

### Обработка ошибок

![Выходим из строя раньше][40]

Я лукавил, когда говорил, что мы не может никуда деться из цепи, для этого
правила есть `Исключение` (простите за каламбур ☺).

Мы всегда можем сбежать с подводной лодки, кинув ошибку (исключение).
Выбрасывание ошибки считается преднамеренным прерыванием текщего потока,
чаще всего из-за того, что вы получили состоянием, которое вы не в силах
исправить. Но будьте осторожны, не все ошибки помогают разработчику при
отладке:

    // jQuery получает это
    $(document.body).on('click', {});
    
    // при щелчке в консоль выведется:
    //   TypeError: ((p.event.special[l.origType] || {}).handle || l.handler).apply is not a function 
    //   in jQuery.min.js on Line 3

Ошибки вроде такой — это огромная головная боль при отладке. Не тратьте
попусту время других людей. Информируйте пользователя API, если он сделал
что-то глупое:

    if (Object.prototype.toString.call(callback) !== '[object Function]') { // см. прим.
      throw new TypeError("callback is not a function!");
    }

Примечание: `typeof callback === "function"` не следует использовать, потому
что старые браузеры могут говорить, что объект — функция, хотя он ей не
является. В Chrome (до версии 12) это происходило с `RegExp`. Для удобства
используйте [jQuery.isFunction()][41] или [_.isFunction()][42].

Большая часть библиотек, которые я встречал, независимо от языка (среди
слаботипизированных) не заботятся о доскональной проверке входных данных.
Честно говоря, мой собственный код проводит валидацию только в тех местах,
где я вижу возможность допустить ошибку. Никто из нас этого не делает, но всем
нам следует делать. Программисты — кучка лентяев, мы пишем код не для того,
чтобы просто писать код или ради чего-то, во что не до конца верим.
Разработчики Perl6 увидели в этом проблему и решили добавить кое-что, что
называется *ограничение параметров*. В JavaScript их подход мог бы выглядеть
похожим образом:

    function validateAllTheThings(a, b {where typeof b === "numeric" and b < 10}) {
      // Интерпретатор должен кинуть ошибку,
      // если b не число или больше 9
    }

Синтаксис, конечно, уродливый, но идея в том, чтобы сделать валидацию входных
данных полноценной частью языка. В JavaScript на это даже намёка нет.
Это и к лучшему, я всё равно не могу представить, чтобы я вбивал эти
ограничения в сигнатуры функций. Это признание проблемы (слаботипизированных
языков), которая является интересной частью этой истории.

JavaScript не слабый и не ущербный, просто нам нужно работать немного
упорнее, чтобы заставить наши штуки работать действительно хорошо. Хороший
код не означает, что мы должны принять любые данные, взмахнуть волшебной
палочкой и получить результат. Хороший код означает, не принимать чепуху
*и говорить разработчику об этом*.

Думайте о валидации входных данных так: Несколько строчек кода за кулисами
вашего API придадут вам уверенности, что ни один разработчик не потратит часы
на ловлю причудливых багов из-за того, что он случайно передал в ваш код
строку вместо числа. Это как раз тот случай, когда вы можете сказать людям,
что *они неправы*, и они ещё и поблагодарят вас за это.

### Переходим к асинхронности

До этого момента мы рассматривали синхронные API. Асинхронные методы обычно
принимают коллебеки, чтобы проинформировать окружающий мир что определённая
работа завершилась. Не очень-то подходит к нашей схеме текучего интерфейса:

    Api.protoype.async = function(callback) {
      console.log("async()");
      // делаем что-нибудь асинхронно
      window.setTimeout(callback, 500);
      return this;
    };
    Api.protoype.method = function() {
      console.log("method()");
      return this;
    };
    
    // запускаем
    api.async(function() {
      console.log('callback()');
    }).method();
    
    // выведется: async(), method(), callback()

Этот пример показывает, как асинхронный метод `async()` начинает свою работу,
но сразу же за этим следует возврат, это приводит к тому, что `method()`
вызывается раньше, чем `async()` успеет выполнить свою задачу. Есть случаи,
когда мы хотим, чтобы так и произошло, но обычно мы ожидаем, что `method()`
запустится *после* того, как `async()` закончит работу.

#### Дефёрреды (Промисы)

В какой-то степени мы можем справиться с такой кашей из вызовов синхронного и
асинхронного API при помощи [Промисов][43]. jQuery знает их как
[Дефёрреды][44]. Объект `Deferred` возвращается вместо обычного `this`, что
выбрасывает нас из цепочки вызовов. Это поначалу кажется необычным, но
фактически это оберегает нас от продолжения синхронных вызовов после вызова
асинхронного метода:

    Api.protoype.async = function() {
      var deferred = $.Deferred();
      console.log("async()");
    
      window.setTimeout(function() {
        // do something asynchronous
        deferred.resolve("some-data");
      }, 500);
    
      return deferred.promise();
    };
    
    api.async().done(function(data) {
      console.log("callback()");
      api.method();
    });
    
    // prints: async(), callback(), method()

Объект `Deferred` позволяет регистрировать обработчики при помощи `.done()`,
`.fail()`, `.always()`. Эти обработчики будут вызваны в случае завершения,
неудачи, или независимо от состояния. См. [Конвееры промисов в JavaScript][45]
для более детального описания дефёрредов.

### Отладка текчих интерфейсов

Хотя с *текучими интерфейсамы* и гораздо приятней разрабатывать, у них есть
определённые ограничения в возможностях их отладки.

Как и с любым кодом, 

As with any code, *разработка через тестирование* (TDD) — это простой способ
уменьшить потребность в отладке. Я писал URI.js с использованием TDD и не
сталкивался с какими-нибудь серьёзными затруднениям с отладкой. Но с другой
стороны, разработка через тестирование лишь уменьшает необходимость отладки,
она не заменяе её полностью.

Кто-то в интернете советует присать каждый копонент цепочки вызовов в своей
собственной строке, чтобы получить вместяемые номера строк в стектрейсе:

    foobar.bar()
      .baz()
      .bam()
      .someError();

У такой техники есть свои преимущества (хотя облегчение отладки тут и не самая
важная часть). Код, написанный как в примере выше, ещё проще читать.
Построчное сравнение (которое используется в системах контроля версий вроде
SVN и GIT) тоже могт от этого выиграть. А что касается отладки, только в
Chrome (на момент написания статьи) `someError()` покажется на 4 строке,
остальные браузеры будут считать, что ошибка на строке 1.

Даже добавление простого метода для записи происходящего с вашими объектами
в лог может серьёзно помочь. Хотя это и считается «отладкой вручную» и может
вызывать ухмылку у людей, привыкших к «настоящим» дебаггерам:

    DateInterval.prototype.explain = function() {
      // выводим текущее состояние в консоль
      console.dir(this);
    };
    
    var days = (new Date(2012, 0, 1))
      .until(2012, 11, 31) // возвращает экземпляр DateInterval
      .explain() // пишем отладочную информацию в консоль
      .days(); // 365

#### Имена функций

На всём протяжении этой статьи вы увидели много примеров кода в стилистике
`Foo.prototype.something = function(){}`. Такой стиль был выбран для краткости
примеров. Но когда вы будете писать код, вам может понадобиться один из
следующих подходов для того, чтобы ваша консоль могла правильно показывать
имена функций:

    Foo.prototype.something = function something() {
      // трали-вали
    };

    Foo.prototype.something = function() {
      // трали-вали
    };
    Foo.prototype.something.displayName = "Foo.something";

Второй способ, `displayName` был представлен в WebKit, а затем появился и в
Firebug / Firefox. С `displayName` написать кода придётся немного больше,
но это позволит использовать произвольные имена, включаяя пространства имён
или связанный объект. Любой из этих подходов может немного помочь при работе с
анонимными функциями.

Узнать больше вы сможете у [kangax][12] в статье
[Разъяснения насчет именованных функций-выражений][46].

### Документирование API

Одна из самых сложных задач разработки ПО — это написание документации.
Практически все ненавидят это делать, но при это все жалуются на плохую или
отсутствующую документацию тех утилит, с которыми им нужно работать.
Есть много разнообразных утилиты, призванных помочь и автоматизировать процесс
документирования вашего кода:

-   [YUIDoc][YUIDoc] (требует Node.js, npm)
-   [JsDoc Toolkit][JsDoc Toolkit] (требует Node.js, npm)
-   [Markdox][Markdox] (требует Node.js, npm)
-   [Dox][Dox] (требует Node.js, npm)
-   [Docco][Docco] (требует Node.js, Python, CoffeeScript)
-   [JSDuck][JSDuck] (требует Ruby, gem)
-   [JSDoc 3][JSDoc 3] (требует Java)

Все эти утилиты так или иначе вызывают разочарование. JavaScript — очень
динамичный язык, и тем самым особенно разнообразен в выражениях. Из-за этого
со многими вещами таким утилитам очень сложно справиться. Ниже список причин,
почему я решил подготавливать документацию в простом HTML, markdown или
[DocBoock][47] (если проект достаточно большой). У jQuery, например, точно
такие же проблемы, и его разработчики вообще не документируют свой API в
коде.

1.  Сигнатуры функций — это ещё не всё, что требуется от документации, но
    большая часть утилит сосредоточены именно на этом.

2.  Примеры кода имеют большое значение в объяснении, как что-то работает.
    В обычной документации API обычно это не получается нормально сделать.

3.  Документирование кода обычно не справляется с объяснением процессов,
    происходящих *за кулисами* (поток, события и т.п.)

4.  Документирование методов с несколькими сигнатурами обычно очень
    болезненно.

5.  Документирование методов с объектами опций часто нетривиально.

6.  Сгенерированные методы обычно нелегко документировать, это же касается и
    коллбеков по умолчанию.

Если вы не можете (или не хотите) подстраивать ваш код под одну из приведённых
выше утилит для документирования и предпочитаете делать документацию
«на коленке», то проекты вроде [Document-Bootstrap][48] могли бы сберечь ваше
время.

Убедитесь, что ваша документация — это нечно большее, чем автоматически
сгенерированный текст. Ваши пользователи будут благодарны за предосталвенные
примеры. Расскажите им, как ваша программа работает, и когда какие события
происходят. Нарисуйте схему, если это поможет пользователям разобраться, как
ваш API делает то или иное. И прежде всего: поддерживайте синхронизацию
между кодом и документацией!

#### Самоочевидный код

Обеспечение разработчиков хорошей документацией не удержит их от чтения
ваших исходников, ваш код — сам по себе часть документации. Если
документации станет не хватать (а у каждой документации есть свои пределы),
разработчики прибегнут к чтению исходного кода, чтобы получить ответы на
их вопросы. В действительности, вы тоже к ним относитесь. Скорее всего, вы
сами будете читать ваш собственный код снова и снова, через недели, месяцы
или даже годы.

Вы должны писать самоочевидный код. Чаще всего это не проблема, потому как
самое сложное — это давать вещам (функциям, переменным и т.п.) имена и
соблюдать внутреннюю концепцию. Если вы поймёте, что пишете комментарии в
коде, объясняющие, каким образом он что-то делает, то наверняка вы просто
тратите время, своё и читателя. Используйте комментарии, объясняющие, *почему*
вы решили проблему именно так, а не *как* вы решили проблему. «Как» должно
быть очевидно из вашего кода, так что не повторяйтесь. Обратите внимание, что
использование комментариев для визуальной разметки блоков вашего кода или для
объяснения общих принципов вполне допустимо.

### Заключение

*   API — это соглашение между вами (поставщиком) и пользователем
    (потребителем). Не меняйте беспричинно вещи между версиями.

*   Уделяйте столько же времени на вопрос *Как люди будут пользоваться моим
    кодом?*, как и на вопрос *Как моя программа работает внутри?*

*   При помощи пары простых трюков вы можете значительно уменьшить усилия
    разработчика (если считать в строчках кода).

*   Обрабатывайте невалидные входные данные как можно раньше, бросайте ошибки.

*   Хорошие API гибкие, а те API, которые не дадут допустить ошибку, ещё
    лучше.

Продолжите изучение с видео
[Повторное использование кода — хорошо или великолепно][49] ([слайды][50]),
выступлением [Джейка Арчибальда][15] о разработке API. Ещё в 2007 Джошуа
Блох высупал с презентацией
[Как разработать хороший API и почему это важно][51] на Google Tech Talks.
Хотя он говорил не о JavaScript, изложенные им основные принципы вполне
применимы.

Если вы интересуетесь скоростью разработки API, взгляните на
[Важные паттерны разработки в JS][52] [Эдди Османи][53], чтобы узнать больше
о том, как устроить код изнутри.

*Спасибо [@bassistance][54], [@addyosmani][53] и [@hellokahlil][55] за то,
что нашли время на корректуру этой статьи.*

 [1]: img/Pie-chart.jpg "Time Spent On Creating Vs Time Spent On Using"
 [2]: http://en.wikipedia.org/wiki/Fluent_interface#JavaScript
 [3]: http://martinfowler.com/bliki/FluentInterface.html
 [4]: http://medialize.github.com/URI.js/
 [5]: https://twitter.com/leaverou
 [6]: http://lea.verou.me/chainvas/
 [7]: http://underscorejs.org/#chain
 [8]: http://en.wikipedia.org/wiki/Method_chaining
 [9]: http://en.wikipedia.org/wiki/Command-query_separation
 [10]: http://api.jquery.com/css/

 [11]: http://perfectionkills.com/extending-built-in-native-objects-evil-or-not/
 [12]: https://twitter.com/kangax

 [13]: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/valueOf

 [14]: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toString
 [15]: https://twitter.com/jaffathecake
 [16]: http://www.slideshare.net/slideshow/embed_code/5426258?startSlide=59
 [17]: img/good-intention.jpg "Good Intentions"
 [18]: http://api.jquery.com/on/

 [19]: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/arguments
 [20]: https://developer.mozilla.org/en-US/docs/DOM/event.initMouseEvent

 [21]: http://www.diveintopython.net/power_of_introspection/optional_arguments.html
 [22]: http://wiki.ecmascript.org/doku.php?id=harmony:parameter_default_values
 [23]: http://wiki.ecmascript.org/doku.php?id=harmony:rest_parameters
 [24]: http://api.jquery.com/jquery.ajax/
 [25]: http://api.jquery.com/jQuery.extend/
 [26]: http://underscorejs.org/#extend
 [27]: http://api.prototypejs.org/language/Object/extend/
 [28]: http://api.jquery.com/toggle/
 [29]: img/developing-possibilities.jpg "Developing Possibilities"
 [30]: https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference
 [31]: http://api.jquery.com/jQuery.cssHooks/
 [32]: http://blog.rodneyrehm.de/archives/11-jQuery-Hooks.html
 [33]: img/duplication.jpg "Duplication"
 [34]: https://twitter.com/rmurphey
 [35]: http://rmurphey.com/blog/2010/07/12/patterns-for-dry-er-javascript/
 [36]: https://twitter.com/mathias

 [37]: http://slideshare.net/mathiasbynens/how-dry-impacts-javascript-performance-faster-javascript-execution-for-the-lazy-developer
 [38]: http://docstore.mik.ua/orelly/webprog/jscript/ch11_02.htm
 [39]: http://docstore.mik.ua/orelly/webprog/jscript/index.htm
 [40]: img/fail-faster.jpg "Fail Fast"
 [41]: http://api.jquery.com/jQuery.isfunction/
 [42]: http://underscorejs.org/#isFunction
 [43]: http://wiki.commonjs.org/wiki/Promises/A
 [44]: http://api.jquery.com/category/deferred-object/
 [45]: http://sitr.us/2012/07/31/promise-pipelines-in-javascript.html
 [46]: http://kangax.github.com/nfe/
 [47]: http://en.wikipedia.org/wiki/DocBook
 [48]: http://gregfranko.com/Document-Bootstrap/
 [49]: http://vimeo.com/35689836

 [50]: http://www.slideshare.net/jaffathecake/reusable-code-for-good-or-for-awesome
 [51]: http://www.youtube.com/watch?v=heh4OeB9A-c
 [52]: http://addyosmani.com/resources/essentialjsdesignpatterns/book/
 [53]: https://twitter.com/addyosmani
 [54]: https://twitter.com/bassistance
 [55]: https://twitter.com/hellokahlil

 [YUIDoc]: http://yui.github.com/yuidoc/
 [JsDoc Toolkit]: https://github.com/p120ph37/node-jsdoc-toolkit
 [Markdox]: https://github.com/cbou/markdox
 [Dox]: https://github.com/visionmedia/dox
 [Docco]: http://jashkenas.github.com/docco/
 [JSDuck]: https://github.com/senchalabs/jsduck
 [JSDoc 3]: https://github.com/jsdoc3/jsdoc